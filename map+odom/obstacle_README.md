# obstacle.py

## What
This program receives the .pcd file generated by another ROS node, `pointcloud_to_pcd`, with the information got from `realsense_camera2_opensource_tracking.launch`. 
It changes the 3D cloudpoint map to 2D array, using '3' to mark the obstacles that may block the robot, and '0' to mark the road.
The purpose of the program is to generate a text file with a 2D array to represent the room map.

## Why
In the autonomous mode, we hope the robot to sterilize the whole room with the shortest path, which means undisinfected the room in the shortest time.
To planning the path, the algorithm need the map of the room. 
Moreover, in the remote control mode, the user can't stay in the room, so they have to know the location of the obstacle. Thus, we want to use this program to generate the obstacle map.

## How
We first create a node for launching program in  `ROS`, and run the main `obstacle_node()` function.
```python
def obstacle_node():
    rospy.init_node('UVbot_obstacle', anonymous=True)
    while not rospy.is_shutdown():
        make_obstacle_map()
```
The camera and the ROS SLAM function generate .pcd files once every unfixed period of time. `pcd_exist` is a function to check if there are .pcd files in the directory. If yes, let the variable `filename` be the name of one of the pcd files and return `True`. Otherwise, return `False`.


`make_obstacle_map()` generates a 2D array conprised of 0 and 3, where  
'3' indicates obstacles;
'0' the rest. 

Then it will output a text file `obstacle_map` including the array and related information, including the size of the array and the origin coordinate of the robot.

Following is how we achieved it.

First, read a .pcd file, and get the pointcloud data of the map. The pointcloud data begin with some overall information which is not important in our case. Following that is points' information , including x-axis, y-axis, z-axis and color.
The color of the point is not important. Because the robot is only 1.8 meters tall, we just have to care about the obstacle shorter than 1.8 meters, which means `z<1.8`. The file 'obstacle_tmp.txt' records the obstacle that is shorter than 1.6 meters.

```python
if float(line[2]) < 1.6:
    line[2] = str(0)
    newlines.append(line)
```

Second, read the file 'obstacle_tmp.txt' and find the range of the pointcloud. Construct an array representing the map, each of the element represented a 2cm*2cm space. The elements are denoted by the number of the points in their representing space.
```python
total_x = (max_x - min_x) * 5.0
total_y = (max_y - min_y) * 50
```

There are errors from the camera and the pointcloud generator, so the array now may not be the real map of the room. So we try to modify the obstacles and make the map more smooth.
If a space is around a lot of point, it means that the space is highly possible to have an obstacle on it. So we check how many points are there around every 2cm*2cm space.
For every element, count how many points are around the representing space, and add the number to its own number. If the final number is larger than a variable (thres), denote the element by '3', otherwise denote it by '0'.
This is a piece of the code that try to smooth the map:
```python
for i in range(range_x):
    for j in range(range_y):
        count = 0
        if i>0 and j>0 and i<range_x-2 and j<range_y-2:
            if dot_dict[((i-1), (j-1))] > thres:
                count += 1
```

After the process above, an obstacle map has been mainly made. However, because the array represents a rectangle, and the condition outside the room wall can't be detected by the camera, we have to mark out the space outside the room.
The method we use is to detect from four sides of the map. Denote elements by '3' until we detect one element that is '3' originally.
This is the code we use to mark the space outside the room "from bottom to top":
```python
    for i in range(range_x):
        for j in range(range_y-1):
            if dot_dict[(i, j)] <= 0:
                fill_dict[(i, j)] = 1
                if dot_dict[(i, j+1)] > 0:
                    break
```

Finally, write the array to the file 'obstacle_smooth_fill.txt'. The two lines in the bottom of the file represent "the origin of the robot" and "the size of the room".



